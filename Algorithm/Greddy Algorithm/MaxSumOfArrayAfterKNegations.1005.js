/**
第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
第二步：从前向后遍历，遇到负数将其变为正数，同时K--
第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
第四步：求和
*/

/*
  贪心1的思路，
  局部最优：让绝对值大的负数变为正数，当前数值达到最大，
  整体最优：整个数组和达到最大
  局部最优可以推出全局最优。

  那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。
  那么又是一个贪心2：
  局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），
  全局最优：整个 数组和 达到最大
*/

const largestSumAfterKNegations = (nums, k) => {
  nums.sort((a, b) => Math.abs(b) - Math.abs(a)); // 1

  //2
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < 0 && k > 0) {
      nums[i] = -nums[i];
      k--;
    }
  }

  //3.若k还大于0,则寻找最小的数进行不断取反
  while (k > 0) {
    nums[nums.length - 1] = -nums[nums.length - 1];
    k--;
  }

  return nums.reduce((a, b) => a + b);
};
